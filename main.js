/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, visit the plugin's github repository
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ScripterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var SCRIPT_MARKERS = {
  CHARACTER: "@",
  PARENTHETICAL: "("
};
var SCENE_REGEX = /^(\d+[.\s]\s*)?((?:INT|EXT|INT\/EXT|I\/E)[.\s])/i;
var TRANSITION_REGEX = /^((?:FADE (?:IN|OUT)|[A-Z\s]+ TO)(?:[:.]?))$/;
var PARENTHETICAL_REGEX = /^(\(|（).+(\)|）)\s*$/i;
var OS_DIALOGUE_REGEX = /^(OS|VO|ＯＳ|ＶＯ)[:：]\s*/i;
var CSS_CLASSES = {
  SCENE: "script-scene",
  CHARACTER: "script-character",
  DIALOGUE: "script-dialogue",
  PARENTHETICAL: "script-parenthetical",
  TRANSITION: "script-transition",
  ACTION: "script-action"
};
var LP_CLASSES = {
  SCENE: "lp-scene",
  CHARACTER: "lp-character",
  DIALOGUE: "lp-dialogue",
  PARENTHETICAL: "lp-parenthetical",
  TRANSITION: "lp-transition",
  SYMBOL: "lp-marker-symbol"
};
var ScripterPlugin = class extends import_obsidian.Plugin {
  onload() {
    this.addSettingTab(new ScripterSettingTab(this.app, this));
    this.addCommand({
      id: "renumber-scenes",
      name: "Renumber scenes",
      editorCallback: (editor) => this.renumberScenes(editor)
    });
    this.registerMarkdownPostProcessor((element, context) => {
      var _a, _b;
      const frontmatter = context.frontmatter;
      const cssClasses = (frontmatter == null ? void 0 : frontmatter.cssclasses) || [];
      if (!Array.isArray(cssClasses) || !cssClasses.includes("fountain") && !cssClasses.includes("script")) {
        return;
      }
      const lines = Array.from(element.querySelectorAll("p, div, blockquote, li"));
      let previousType = null;
      for (let i = 0; i < lines.length; i++) {
        let p = lines[i];
        let splitIndex = -1;
        let splitTextNode = null;
        let splitOffset = -1;
        const childNodes = Array.from(p.childNodes);
        for (let j = 0; j < childNodes.length; j++) {
          const node = childNodes[j];
          if (node.nodeName === "BR") {
            splitIndex = j;
            break;
          }
          if (node.nodeType === Node.TEXT_NODE && node.textContent) {
            const nl = node.textContent.indexOf("\n");
            if (nl !== -1) {
              splitIndex = j;
              splitTextNode = node;
              splitOffset = nl;
              break;
            }
          }
        }
        if (splitIndex !== -1) {
          let textBefore = "";
          for (let k = 0; k < splitIndex; k++)
            textBefore += childNodes[k].textContent || "";
          if (splitTextNode) {
            textBefore += splitTextNode.textContent.substring(0, splitOffset);
          }
          textBefore = textBefore.trim();
          const firstFormat = this.detectExplicitFormat(textBefore);
          if ((firstFormat == null ? void 0 : firstFormat.typeKey) === "CHARACTER") {
            const newP = createEl("p");
            newP.addClass(CSS_CLASSES.DIALOGUE);
            for (let k = splitIndex + 1; k < childNodes.length; k++) {
              newP.appendChild(childNodes[k]);
            }
            if (splitTextNode) {
              const fullText = splitTextNode.textContent || "";
              const textAfter = fullText.substring(splitOffset + 1);
              splitTextNode.textContent = fullText.substring(0, splitOffset);
              if (textAfter.trim()) {
                newP.prepend(document.createTextNode(textAfter));
              }
            } else {
              p.removeChild(childNodes[splitIndex]);
            }
            p.textContent = textBefore;
            this.applyFormatToElement(p, firstFormat);
            previousType = "CHARACTER";
            if ((_a = newP.textContent) == null ? void 0 : _a.trim()) {
              p.insertAdjacentElement("afterend", newP);
              previousType = "DIALOGUE";
            }
            continue;
          }
        }
        let text = ((_b = p.textContent) == null ? void 0 : _b.trim()) || "";
        if (!text) {
          previousType = null;
          continue;
        }
        const explicitFormat = this.detectExplicitFormat(text);
        if (explicitFormat) {
          this.applyFormatToElement(p, explicitFormat);
          previousType = explicitFormat.typeKey;
        } else {
          if (previousType === "CHARACTER" || previousType === "PARENTHETICAL" || previousType === "DIALOGUE") {
            p.addClass(CSS_CLASSES.DIALOGUE);
            previousType = "DIALOGUE";
          } else {
            p.addClass(CSS_CLASSES.ACTION);
            previousType = "ACTION";
          }
        }
      }
    });
    this.registerEditorExtension(this.livePreviewExtension());
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        menu.addItem((item) => {
          item.setTitle("Scripter").setIcon("film");
          const subMenu = item.setSubmenu();
          subMenu.addItem((startItem) => {
            startItem.setTitle("Scene heading").setIcon("clapperboard");
            const sceneMenu = startItem.setSubmenu();
            sceneMenu.addItem((i) => i.setTitle("EXT.").onClick(() => this.insertText(editor, "EXT. ", false)));
            sceneMenu.addItem((i) => i.setTitle("INT.").onClick(() => this.insertText(editor, "INT. ", false)));
            sceneMenu.addItem((i) => i.setTitle("I/E.").onClick(() => this.insertText(editor, "INT./EXT. ", false)));
          });
          this.addMenuItem(subMenu, "Character (@)", "user", editor, SCRIPT_MARKERS.CHARACTER);
          this.addMenuItem(subMenu, "Parenthetical ( ( )", "italic", editor, SCRIPT_MARKERS.PARENTHETICAL);
          subMenu.addItem((item2) => {
            item2.setTitle("Transition").setIcon("arrow-right");
            const m = item2.setSubmenu();
            m.addItem((i) => i.setTitle("CUT TO:").onClick(() => this.insertText(editor, "CUT TO:", true)));
            m.addItem((i) => i.setTitle("FADE OUT.").onClick(() => this.insertText(editor, "FADE OUT.", true)));
            m.addItem((i) => i.setTitle("FADE IN:").onClick(() => this.insertText(editor, "FADE IN:", true)));
            m.addItem((i) => i.setTitle("DISSOLVE TO:").onClick(() => this.insertText(editor, "DISSOLVE TO:", true)));
          });
          subMenu.addSeparator();
          subMenu.addItem((subItem) => {
            subItem.setTitle("Renumber scenes").setIcon("list-ordered").onClick(() => this.renumberScenes(editor));
          });
          subMenu.addItem((subItem) => {
            subItem.setTitle("Clear format").setIcon("eraser").onClick(() => this.clearLinePrefix(editor));
          });
        });
      })
    );
  }
  onunload() {
  }
  // ------------------------------------------------------------------
  // Live Preview Extension (CodeMirror 6)
  // ------------------------------------------------------------------
  livePreviewExtension() {
    return import_view.ViewPlugin.fromClass(class {
      constructor(view) {
        this.decorations = this.buildDecorations(view);
      }
      update(update) {
        if (update.docChanged || update.viewportChanged || update.selectionSet) {
          this.decorations = this.buildDecorations(update.view);
        }
      }
      buildDecorations(view) {
        const builder = new import_state.RangeSetBuilder();
        const selection = view.state.selection;
        let previousType = null;
        const hiddenDeco = import_view.Decoration.mark({ class: LP_CLASSES.SYMBOL });
        for (const { from, to } of view.visibleRanges) {
          for (let pos = from; pos <= to; ) {
            const line = view.state.doc.lineAt(pos);
            const text = line.text;
            const trimmed = text.trim();
            let lpClass = null;
            let currentType = "ACTION";
            let shouldHideMarker = false;
            let isCursorOnLine = false;
            for (const range of selection.ranges) {
              if (range.head >= line.from && range.head <= line.to) {
                isCursorOnLine = true;
                break;
              }
            }
            if (!trimmed) {
              currentType = "EMPTY";
            } else if (SCENE_REGEX.test(text)) {
              lpClass = LP_CLASSES.SCENE;
              currentType = "SCENE";
            } else if (TRANSITION_REGEX.test(text)) {
              lpClass = LP_CLASSES.TRANSITION;
              currentType = "TRANSITION";
            } else if (PARENTHETICAL_REGEX.test(text)) {
              lpClass = LP_CLASSES.PARENTHETICAL;
              currentType = "PARENTHETICAL";
            } else if (text.startsWith(SCRIPT_MARKERS.CHARACTER)) {
              lpClass = LP_CLASSES.CHARACTER;
              currentType = "CHARACTER";
              if (!isCursorOnLine) {
                shouldHideMarker = true;
              }
            } else if (OS_DIALOGUE_REGEX.test(text)) {
              lpClass = LP_CLASSES.PARENTHETICAL;
              currentType = "PARENTHETICAL";
            } else {
              if (previousType === "CHARACTER" || previousType === "PARENTHETICAL" || previousType === "DIALOGUE") {
                lpClass = LP_CLASSES.DIALOGUE;
                currentType = "DIALOGUE";
              } else {
                currentType = "ACTION";
              }
            }
            if (lpClass) {
              builder.add(line.from, line.from, import_view.Decoration.line({
                attributes: { class: lpClass }
              }));
            }
            if (shouldHideMarker) {
              builder.add(line.from, line.from + 1, hiddenDeco);
            }
            previousType = currentType;
            pos = line.to + 1;
          }
        }
        return builder.finish();
      }
    }, {
      decorations: (v) => v.decorations
    });
  }
  // ------------------------------------------------------------------
  // Core Logic
  // ------------------------------------------------------------------
  addMenuItem(menu, title, icon, editor, marker) {
    if (menu instanceof import_obsidian.Menu) {
      menu.addItem((item) => {
        item.setTitle(title).setIcon(icon).onClick(() => this.toggleLinePrefix(editor, marker));
      });
    }
  }
  detectExplicitFormat(text) {
    if (SCENE_REGEX.test(text)) {
      return { cssClass: CSS_CLASSES.SCENE, removePrefix: false, markerLength: 0, typeKey: "SCENE" };
    }
    if (TRANSITION_REGEX.test(text)) {
      return { cssClass: CSS_CLASSES.TRANSITION, removePrefix: false, markerLength: 0, typeKey: "TRANSITION" };
    }
    if (PARENTHETICAL_REGEX.test(text)) {
      return { cssClass: CSS_CLASSES.PARENTHETICAL, removePrefix: false, markerLength: 0, typeKey: "PARENTHETICAL" };
    }
    if (OS_DIALOGUE_REGEX.test(text)) {
      return { cssClass: CSS_CLASSES.PARENTHETICAL, removePrefix: false, markerLength: 0, typeKey: "PARENTHETICAL" };
    }
    if (text.startsWith(SCRIPT_MARKERS.CHARACTER))
      return { cssClass: CSS_CLASSES.CHARACTER, removePrefix: true, markerLength: 1, typeKey: "CHARACTER" };
    return null;
  }
  applyFormatToElement(p, format) {
    p.addClass(format.cssClass);
    if (format.removePrefix && format.markerLength > 0) {
      this.stripMarkerFromElement(p, format.markerLength);
    }
  }
  stripMarkerFromElement(element, length) {
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
    const firstTextNode = walker.nextNode();
    if (firstTextNode) {
      let text = firstTextNode.textContent || "";
      const removeCount = length;
      if (text.length >= removeCount) {
        firstTextNode.textContent = text.substring(removeCount);
      }
    }
  }
  renumberScenes(editor) {
    const lineCount = editor.lineCount();
    let sceneCounter = 0;
    for (let i = 0; i < lineCount; i++) {
      const line = editor.getLine(i);
      const trimmed = line.trim();
      const match = trimmed.match(SCENE_REGEX);
      if (match) {
        sceneCounter++;
        const sceneNumStr = sceneCounter.toString().padStart(2, "0") + ". ";
        let contentWithoutNumber = trimmed;
        if (match[1]) {
          contentWithoutNumber = trimmed.replace(/^\d+[.\s]\s*/, "");
        }
        contentWithoutNumber = contentWithoutNumber.trim();
        const newLine = sceneNumStr + contentWithoutNumber;
        if (newLine !== line) {
          editor.setLine(i, newLine);
        }
      }
    }
  }
  toggleLinePrefix(editor, prefix) {
    const cursor = editor.getCursor();
    const lineContent = editor.getLine(cursor.line);
    let newLineContent = lineContent;
    let hasMarker = false;
    for (const marker of Object.values(SCRIPT_MARKERS)) {
      if (lineContent.trim().startsWith(marker)) {
        const matchIndex = lineContent.indexOf(marker);
        const before = lineContent.substring(0, matchIndex);
        const after = lineContent.substring(matchIndex + marker.length);
        if (marker === prefix) {
          newLineContent = before + after;
          hasMarker = true;
        } else {
          newLineContent = before + prefix + after;
          hasMarker = true;
        }
        break;
      }
    }
    if (!hasMarker)
      newLineContent = prefix + lineContent;
    editor.setLine(cursor.line, newLineContent);
  }
  insertText(editor, text, replaceLine = false) {
    const cursor = editor.getCursor();
    const lineContent = editor.getLine(cursor.line);
    if (replaceLine) {
      editor.setLine(cursor.line, text);
    } else {
      editor.setLine(cursor.line, text + lineContent);
    }
  }
  clearLinePrefix(editor) {
    const cursor = editor.getCursor();
    const lineContent = editor.getLine(cursor.line);
    let newLineContent = lineContent;
    for (const marker of Object.values(SCRIPT_MARKERS)) {
      if (lineContent.trim().startsWith(marker)) {
        const matchIndex = lineContent.indexOf(marker);
        const before = lineContent.substring(0, matchIndex);
        const after = lineContent.substring(matchIndex + marker.length);
        newLineContent = before + after;
        editor.setLine(cursor.line, newLineContent);
        return;
      }
    }
  }
};
var ScripterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Usage guide").setHeading();
    new import_obsidian.Setting(containerEl).setName("Getting started").setDesc("How to activate screenplay formatting for a specific note.").setHeading();
    const setupInfo = containerEl.createEl("div", { cls: "setting-item-description" });
    setupInfo.createEl("p", { text: "To enable Scripter features (Live Preview & Print Formatting), adds the following to your note's frontmatter (Properties):" });
    setupInfo.createEl("pre", { text: "---\ncssclasses: fountain\n---" });
    setupInfo.createEl("p", { text: 'Or use "script" instead of "fountain".' });
    containerEl.createEl("br");
    new import_obsidian.Setting(containerEl).setName("Syntax reference").setDesc("Basic rules for formatting your screenplay.").setHeading();
    const syntaxDiv = containerEl.createEl("div");
    const createRow = (title, syntax, desc) => {
      const p = syntaxDiv.createEl("p");
      p.createEl("strong", { text: title + ": " });
      p.createEl("code", { text: syntax });
      p.createSpan({ text: " \u2014 " + desc });
    };
    createRow("Scene Heading", "INT. / EXT.", "Automatic bold & uppercase.");
    createRow("Character", "@NAME", 'Centered. "@" is hidden when not editing.');
    createRow("Dialogue", "Text below Character", "Automatically indented.");
    createRow("Parenthetical", "(emotion) / OS: / VO:", "Centered & Italic.");
    createRow("Transition", "CUT TO: / FADE IN", "Right aligned.");
    containerEl.createEl("br");
    const supportDiv = containerEl.createEl("div", { attr: { style: "margin-top: 20px; border-top: 1px solid var(--background-modifier-border); padding-top: 20px;" } });
    supportDiv.createEl("p", { text: "If you enjoy using Scripter, consider support its development!" });
    const link = supportDiv.createEl("a", { href: "https://buymeacoffee.com/ideo2004c" });
    link.createEl("img", {
      attr: {
        src: "https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png",
        style: "height: 40px;"
      }
    });
  }
};
